\documentclass[english]{article}

\usepackage[latin9]{inputenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{algpseudocode}
\usepackage{booktabs}
\usetikzlibrary{automata,positioning}

\tikzstyle{dir}=[->, very thick]
\tikzstyle{circ}=[draw, circle, very thick]

\title{CIS 511 Homework 4}
\author{Stephen Phillips, Dagaen Golomb}
\date{February 23, 2015}


\begin{document}
\maketitle
\subsection*{Problem 1}
We want to show that finding if a Turing Machine has a \textit{useless state}
is Turing Decidable. We formulate this as a language:
\[ L = \{ \langle M, q \rangle \mid
   q \in Q(M), \;
   \forall s \in \Sigma^* M(q) \, M\textrm{ does not enter }q \} \]

Now we reduce this to $A_{TM}$ to show that it is undecidable. First as usual, 
we suppose toward contradiction that there was a decider of this language, which
we will denote $D$. We build a Turing Machine in the following manner:
\begin{algorithmic}
\Function{$N$}{$\langle M, x \rangle$}
\State Build the description for the following machine
	\Function{A}{$y$}
		\State Ignore input $y$
		\State Simulate $M(x)$, and output what it outputs
	\EndFunction
\State Simulate $D(\langle A, q_A \rangle)$, where $q_A$ is the accept state
		of $D$, and output what it outputs
\EndFunction 
\end{algorithmic}

If $M(x)$ halts and accepts, then we eventually reach the accept state of $A$,
by construction. Also by construction we never reach the accept state if $M(x)$
loops or if it rejects. Since $D$ is a decider, and building the machine
description takes finite time, $N$ always halts. Therefore $N$ accepts if and
only if $D$ accepts, which in turn accepts if and only if
$\langle M,x \rangle \in A_{TM}$. Therefore, $N$ decides $A_{TM}$, a
contradiction. 

\subsection*{Problem 2}
Note that the set of decidable languages is countable. If a language is decidable,
there must exist a Turing Machine which decides it. We proved in class the set of
TMs is countable (via enumerating descriptions of all combinations of bits starting
at length 1 and increasing onward). The set of TM's that decides subset languages in $\{1\}^*$
is a subset of all TM's and is therefore countable. Thus, the set of decidable languages
in $\{1\}^*$ is countable.

Now, using diagonalization, we can prove that the set of all languages of subsets of $\{1\}^*$
is uncountable. This will show that there must be some language that is a subset of $\{1\}^*$ that
is not decidable since the set of TM's deciding languages of this form is countable.

Picture the set of languages that are a subset of $\{1\}^*$ as a bit string with 0 if they include
a particular string in $\{1\}^*$ and 0 otherwise. Suppose this set of languages is countable.
Then we could list all such languages as so:\\

\begin{tabular}{c|c|c|c|c}
	$\epsilon$ & 1 & 11 & 111 & ... \\ \hline
	0 & 0 & 0 & 0 & \\ \hline
	1 & 0 & 0 & 0 & \\ \hline
	0 & 1 & 0 & 0 & \\ \hline
	1 & 1 & 0 & 0 & \\ \hline
	$\vdots$ &&&& $\ddots$ \\
\end{tabular}

Now create the languages where if the $i^{\text{th}}$ entry in the $i^{\text{th}}$ row
is one, that string is not in the language. Conversely, if it is a zero it is in the language.
Now, we have created a language that is clearly composed of substrings of $\{1\}^*$, so it
should be in the table. However, this language conflicts with every table entry, by construction,
by at least one string. But this table is supposed to list all languages of the given form.
This is a contradiction. Therefore, the set of languages that are a subset of $\{1\}^*$
is uncountable.

Thus, we have shown that there must exist a language that is a subset of $\{1\}^*$ that cannot
be decided.

\subsection*{Problem 3}
We want to show that the intersection of two context free languages is
undecidable using $A_{TM}$. 

\subsection*{Problem 4}
\subsection*{Problem 5}
Show that the language
\[ ISO = \{ \langle G, H \rangle \} \mid
		\textrm{$G$ and $H$ are isomorphic graphs} \]
is in NP.

To do this we need to show a verifier $V$ for $ISO$. As one might expect, the
certificate for a member of the language $\langle G, H \rangle$ is the
isomorphism $\phi: V_G \rightarrow V_H, v \rightarrow \phi(v)$ between them.
The size of such an isomorphism would be about $2n$ where $n$ is the number of
nodes in $G$ and $H$, so it polynomial in the size of $G$ and $H$. 
We also need to check that the verifier $V$ using this runs in polynomial
time. A simple algorithm to use this is the following:

\begin{algorithmic}
\Function{$V$}{$\langle G, H \rangle$,$\phi$}
\State If the number of nodes or edges in $G$ differ from the number of nodes
		or edges in $H$, reject
\For{Nodes $v$ in $G$}
	\State If the number of edges $(v,u)$ in $G$ differ from the number of
			edges $(\phi(v),u')$ in $H$, reject
	\For{Edges $(v,u)$ in $G$}
		\State If $(\phi(v),\phi(u))$ is not in $H$, reject
	\EndFor
\EndFor
\State Accept
\EndFunction 
\end{algorithmic}

By assering that the size of the graphs are the same, that each node $v$ has
the same degree as $\phi(v)$ and maps to the corresponding vertices, we have
shown that the isomorphism is correct. If there is no isomorphism then at
least one of these tests will fail. Therefore $V(\langle G, H \rangle,y)$
will accept for some input $y$ if and only if there is an isomorphism between
$G$ and $H$.

\subsection*{Problem 6}

\subsection*{Problem 7}
For a language $A$ to be NP-complete, it needs to satisfy two conditions:
\begin{itemize}
\item $B \in \textrm{NP}$
\item $\forall L \in \textrm{NP}, A \le_p B$
\end{itemize}
We want to show that if $\textrm{P} = \textrm{NP}$, then every language
$A \in P$ exept $A = \varnothing$ and $A = \Sigma^*$ is NP-complete. 

The basic idea is that since we have polynomial time algorithms for all
NP-complete problems like SAT, we map each language to SAT, solve it, then map
that output to appropriate inputs for the original language, i.e. use
$L \le_p \textrm{SAT}$ then that $L \le_p \textrm{SAT}$ (kind of a hack). 

We know that $\textrm{SAT} \in NP$, and since by assumption
$\textrm{P} = \textrm{NP}$, $\textrm{SAT} \in P$. That means there must be a
polynomial time turing machine $M_{SAT}$ that accepts SAT in polynomial time.
We also know that SAT is NP-complete, so for every language $L \in \textrm{NP}$
there is a polynomial time function $f^{SAT}_L : \Sigma^* \rightarrow \Sigma^*$
that satisfies $w \in L \iff f(w) \in \textrm{SAT}$.

Given a language $A \in \textrm{P}$ besides the empty and full languages, we 
know there exists strings $s_{acc} \in A$ and $s_{rej} \notin A$. Since
we assume $\textrm{P} = \textrm{NP}$, we know $A \in \textrm{NP}$. Using all of
this we create the following map for a language $L \in \textrm{P}$:
\begin{algorithmic}
\Function{$f^A_L$}{$x$}
\State Let $y = f^{SAT}_L(x)$
\State Simulate $M_{SAT}(y)$, and record its output
\State If it accepted, output $s_{acc}$
\State Otherwise, output $s_{rej}$
\EndFunction 
\end{algorithmic}

This machine satisfies $x \in L \iff f^A_L(x) \in A$ since it outputs 
$s_{acc} \in A$ if $M_{SAT}$ accepted and $s_{rej} \in A$ if $M_{SAT}$
rejected, and we know $M_{SAT}$ accepts if and only if
$f^{SAT}_L(x) \in \textrm{SAT}$. We also know this runs in polynomial time,
since $f^{SAT}_L(x)$ runs in polynomial time and $M_{SAT}(y)$ runs in 
polynomial time, and the rest are just a constant number of operations.
Therefore this is a polynomial time map from aribtrary language $L$ to 
arbitrary language $A$ and so.

Since $A$ satisfies both the conditions to be NP-complete, and $A$ was 
any language in $P$ (with the two exceptions), then any langauge in P is
NP-complete if $\textrm{P} = \textrm{NP}$.


\end{document}




